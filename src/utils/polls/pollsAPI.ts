import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";
import { _getQuestions, _getUsers, _saveQuestionAnswer, } from "../../data/data";
import { Poll, Question, User } from "../../state-tree/model";
import { PollsState } from "../../state-tree/state-tree";

// The questions
export const fetchQuestions: () => Promise<{ [key: string]: Question }> = () =>
  _getQuestions() as Promise<{ [key: string]: Question }>;

// The users
export const fetchUsers: () => Promise<{ [key: string]: User }> = () =>
  _getUsers() as Promise<{ [key: string]: User }>;

/**
 * Builds a PollsState from questions and users,
 * filtering according to a predicate (answered or not).
 */
async function loadPolls(questions: { [key: string]: Question }, users: { [key: string]: User },
  initialState?: { [key: string]: Poll }
): Promise<PollsState> {
  const authedUser: string = localStorage.getItem('authedUser') as string;
  const totalUsers = Object.values(users).length;

  const polls: Poll[] = Object.values(questions)
    .map((question) => {
      const optionOneVotes = question.optionOne.votes.length;
      const optionTwoVotes = question.optionTwo.votes.length;
      const poll = initialState?.[question.id];
      if (poll) {
        return Object.assign(poll, {
          question,
          answered: question.optionOne.votes.includes(authedUser) || question.optionTwo.votes.includes(authedUser),
          selectedAnswer: (question.optionOne.votes.includes(authedUser) ? 'optionOne' : (question.optionTwo.votes.includes(authedUser) ? 'optionTwo' : undefined)) as 'optionOne' | 'optionTwo' | undefined,
          optionOne: {
            voted: optionOneVotes,
            percentage: `${Math.round((optionOneVotes / totalUsers) * 100)}%`,
          },
          optionTwo: {
            voted: optionTwoVotes,
            percentage: `${Math.round((optionTwoVotes / totalUsers) * 100)}%`,
          },
        });
      }
      return {
        question,
        expand: false,
        answered: question.optionOne.votes.includes(authedUser) || question.optionTwo.votes.includes(authedUser),
        selectedAnswer: (question.optionOne.votes.includes(authedUser) ? 'optionOne' : (question.optionTwo.votes.includes(authedUser) ? 'optionTwo' : undefined)) as 'optionOne' | 'optionTwo' | undefined,
        optionOne: {
          voted: optionOneVotes,
          percentage: `${Math.round((optionOneVotes / totalUsers) * 100)}%`,
        },
        optionTwo: {
          voted: optionTwoVotes,
          percentage: `${Math.round((optionTwoVotes / totalUsers) * 100)}%`,
        },
      };
    })
    .sort((a, b) => b.question.timestamp - a.question.timestamp);

  const pollsEntities = polls.reduce((acc, poll) => {
    acc[poll.question.id] = poll;
    return acc;
  }, {} as PollsState["entities"]);

  return {
    entities: pollsEntities,
    status: "idle",
  };
}

/**
 * RTK Query slice that builds poll state from questions and users.
 * Defined with createApi, reducerPath: "pollsApi".
 * Provides buildPolls query invoking loadPolls to compute PollsState.
 * Exported hook useBuildPollsQuery, endpoint buildPolls, and middleware for store integration.
 */
const pollsApi = createApi({
  reducerPath: "pollsApi",
  baseQuery: fetchBaseQuery({ baseUrl: "/" }), // not needed here since we call local functions
  endpoints: (builder) => ({
    buildPolls: builder.query<PollsState, { questions: { [key: string]: Question }, users: { [key: string]: User }, initialState?: { [key: string]: Poll } }>({
      async queryFn({ questions, users, initialState }) {
        try {
          return { data: await loadPolls(questions, users, initialState) };
        } catch (err: any) {
          return { error: err };
        }
      },
    }),
    setExpanded: builder.mutation<{ [key: string]: Poll }, { pollId: string, expanded: boolean }>({
      queryFn({ pollId, expanded }: { pollId: string, expanded: boolean }, { getState }: any) {
        const state = getState() as { pollsApi: { [key: string]: Poll } };
        const buildPolls = Object.values(state.pollsApi.queries)
          .sort((a, b) => (b.fulfilledTimeStamp || 0) - (a.fulfilledTimeStamp || 0))
          .find(value => value.endpointName === "buildPolls" && value.status === "fulfilled");
        const currentPoll = buildPolls?.data?.entities[pollId];
        if (!currentPoll) {
          console.warn(`Poll with id ${pollId} not found`);
          return { data: buildPolls?.data?.entities || {} };
        }
        const mutatedPoll = { ...currentPoll, expand: expanded };
        const updatedEntities = { ...buildPolls?.data?.entities, [pollId]: mutatedPoll };
        return { data: updatedEntities || {} };
      },
    }),
  }),

});

/**
 * Hook generated by RTK Query to fetch and build poll state.
 * Calls loadPolls with provided questions and users.
 * Returns { data: PollsState, isLoading } as seen in DashboardComponent.
 * Exported from src/utils/polls/pollsAPI.ts alongside buildPolls endpoint.
 */
export const { useBuildPollsQuery, useSetExpandedMutation } = pollsApi;
export const { buildPolls, setExpanded } = pollsApi.endpoints;
export default pollsApi;